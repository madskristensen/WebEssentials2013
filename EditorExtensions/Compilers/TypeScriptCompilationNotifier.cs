using System;
using System.Collections.Generic;
using System.IO;
using EnvDTE;
using MadsKristensen.EditorExtensions.Commands;
using Microsoft.Html.Editor;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Text;

namespace MadsKristensen.EditorExtensions.Compilers
{
    ///<summary>An <see cref="ICompilationNotifier"/> that watches for TypeScript files generated by VS' built-in async compiler.</summary>
    internal class TypeScriptCompilationNotifier : ICompilationNotifier
    {
        private readonly ICollection<IFileSaveListener> _listeners;
        private readonly FileSystemWatcher _watcher;
        public ITextDocument Document { get; private set; }
        public string SourceFilePath { get { return Document.FilePath; } }
        public string TargetFilePath { get { return GetOutputFileName(); } }

        private bool _isReady;

        private string _outputFile;

        private string GetOutputFileName()
        {
            if (!string.IsNullOrEmpty(_outputFile))
                return _outputFile;

            IVsSolution solution = EditorExtensionsPackage.GetGlobalService<IVsSolution>(typeof(SVsSolution));
            Project project = ProjectHelpers.GetProject(SourceFilePath);
            IVsHierarchy hierarchy;
            ErrorHandler.ThrowOnFailure(solution.GetProjectOfUniqueName(project.UniqueName, out hierarchy));

            IVsBuildPropertyStorage buildPropertyStorage = hierarchy as IVsBuildPropertyStorage;

            if (buildPropertyStorage == null)
            {
                _outputFile = Path.ChangeExtension(SourceFilePath, ".js");
            }
            else
            {
                string outputFile, outputDir;
                string config = EditorExtensionsPackage.DTE.Solution.SolutionBuild.ActiveConfiguration.Name;
                ErrorHandler.ThrowOnFailure(buildPropertyStorage.GetPropertyValue("TypeScriptOutFile", config, (uint)_PersistStorageType.PST_PROJECT_FILE, out outputFile));
                ErrorHandler.ThrowOnFailure(buildPropertyStorage.GetPropertyValue("TypeScriptOutDir", config, (uint)_PersistStorageType.PST_PROJECT_FILE, out outputDir));

                if (!string.IsNullOrEmpty(outputFile))
                {
                    _outputFile = Path.Combine(ProjectHelpers.GetRootFolder(project), outputFile);
                }
                else if (!string.IsNullOrEmpty(outputDir))
                {
                    string dir = Path.Combine(ProjectHelpers.GetRootFolder(project), outputDir);
                    string file = Path.ChangeExtension(Path.GetFileName(SourceFilePath), ".js");
                    _outputFile = Path.Combine(dir, file);
                }
            }

            if (string.IsNullOrEmpty(_outputFile))
                _outputFile = Path.ChangeExtension(SourceFilePath, ".js");

            return _outputFile;
        }

        public TypeScriptCompilationNotifier(ITextDocument doc)
        {
            Document = doc;
            Document.FileActionOccurred += Document_FileActionOccurred;

            _listeners = Mef.GetAllImports<IFileSaveListener>(ContentTypeManager.GetContentType("JavaScript"));

            _watcher = new FileSystemWatcher(Path.GetDirectoryName(TargetFilePath));
            _watcher.Filter = Path.GetFileName(TargetFilePath);
            _watcher.EnableRaisingEvents = true;
            _watcher.Created += FileTouched;
            _watcher.Changed += FileTouched;
        }

        private void Document_FileActionOccurred(object sender, TextDocumentFileActionEventArgs e)
        {
            if (e.FileActionType != FileActionTypes.DocumentRenamed)
                return;

            _watcher.Path = Path.GetDirectoryName(TargetFilePath);
            _watcher.Filter = Path.GetFileName(TargetFilePath);
        }


        ///<summary>Releases all resources used by the EditorCompilerInvoker.</summary>
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        ///<summary>Releases the unmanaged resources used by the EditorCompilerInvoker and optionally releases the managed resources.</summary>
        ///<param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                Document.FileActionOccurred -= Document_FileActionOccurred;
                _watcher.Created -= FileTouched;
                _watcher.Changed -= FileTouched;
                _watcher.Dispose();
            }
        }

        ///<summary>Occurs when the file has been compiled (on both success and failure).</summary>
        public event EventHandler<CompilerResultEventArgs> CompilationReady;
        ///<summary>Raises the CompilationReady event.</summary>
        ///<param name="e">A CompilerResultEventArgs object that provides the event data.</param>
        protected virtual void OnCompilationReady(CompilerResultEventArgs e)
        {
            if (CompilationReady != null)
                CompilationReady(this, e);
        }

        private void FileTouched(object sender, FileSystemEventArgs e)
        {
            // The check for _isReady is in place to deal with the issue where
            // FileSystemWatcher fires twice per file change.
            if (!_isReady)
            {
                _isReady = true;
                return;
            }

            if (File.Exists(TargetFilePath))
            {
                RaiseReady();

                foreach (var listener in _listeners)
                    listener.FileSaved(ContentTypeManager.GetContentType("JavaScript"), TargetFilePath, false, false);
            }
            _isReady = false;
        }

        public void RequestCompilationResult(bool cached)
        {
            if (File.Exists(TargetFilePath))
                RaiseReady();
            else
                OnCompilationReady(new CompilerResultEventArgs(new CompilerResult(SourceFilePath, null)
                {
                    IsSuccess = true,   // HACK: Set IsSuccess to true to force margin to display result
                    Result = "// Not compiled to disk yet"
                }));
        }

        private void RaiseReady()
        {
            OnCompilationReady(new CompilerResultEventArgs(new CompilerResult(SourceFilePath, TargetFilePath)
            {
                IsSuccess = true,
                Result = File.ReadAllText(TargetFilePath)
            }));
        }
    }
}